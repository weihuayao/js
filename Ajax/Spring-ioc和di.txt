Spring 4

**1 ioc  控制反转。****

​	容器 主动将资源推送给管理的组件 ，组件选择合适的方式来接受资源。

di 依赖注入  ioc的另一种表述方式。 

#### **2 bean的配置****

![1544430996107](C:\Users\anan\AppData\Roaming\Typora\typora-user-images\1544430996107.png)

 interface   applicationContext    ->classpathXmlApplicationContext/fileSystemXmlApplicationContext  

**2.1 基于xml文件的方式**

**2.1.1**

<bean id = ""  class ="">

<property name ="" value=""></property>

</bean>

**2.1.2**

<bean id = ""  class ="">

<construct-args value="" index ="0" type=""></construct-args>

<construct-args value="" index="1" type=""></construct-args>

<construct-args index="1" type="">

<value>  </value>

</construct-args>

</bean>

**2.2自动装配**

**2.2.1 atuowire 自动装配**

​	byName	 根据当前	bean的setter风格的属性名自动装配 ，若有匹配，则自动装配。

​	byType	根据bean的类型和bean的类型进行自动装配。若有ioc容器有多个类型则抛出异常。

​	缺点：atuowire装配所属性当需要部分属性时不够灵活 ，atuowire只能选择byName byType装配。

**2.3.bean的继承**

<bean id = "" class=""   p:city=" "  p:stree="" ></bean>   父bean

<bean id = "" P:stree=""  parent=""></bean> 子bean

<bean id = "" class=""   p:city=" "  p:stree="" abstract="true" ></bean>	  抽象bean不能被实例 ，只能继承作为模板。父bean可以省略类名作为模板。同时abstract="true"。

**2.4依赖bean的配置** 

​	Spring允许用户通过depends-on属性设定bean的前置依赖bean  如果有多个则可通过逗号	，空格配置多个bean的名称。

**2.5使用bean的 属性来配置bean的作用域 。**

​	 默认值为singleton。在整个容器的生命周期内值创建一个bean 。单例模式

<bean  scope="singleton"></bean>

prototype 初始时不创建bean的实例  ，在每次请求时 创建一个新的bean实例。并返回。

**2.5使用bean的 属性来配置bean的作用域 。****

**2.6Spring表达式语言 SpEl**

<bean id="" class="">

<property name =" " value="#{'adderss'}"/>

</bean>

**2.7IOC容器中bean的生命周期的方法。**

​	通过构造器或者工厂方法创建bean的实例 -->为bean的属性值设置和其他队bean的引用--> 调用bean的初始化方法-->bean可以使用-->容器关闭 调用bean的销毁方法。

![1544446050547](C:\Users\anan\AppData\Roaming\Typora\typora-user-images\1544446050547.png)

**2.8通过工厂方法配置bean。**

​	**调用静态工厂方法就可以返回bean的实例。**

```java
<bean id= "" class="" factory-method ="">

  <construct-arg value =""> </construct-arg>

</bean>
```

​	**实例工厂方法返回bean的实例**

```java
<bean id="" class=""    >

<bean id= "" factory-bean="" factory-method ="">

      <construct-arg value =""> </construct-arg>

</bean>
```

​	**factorybean返回bean的实例**	

​	1，自定义factory实现 FactoryBean接口 ,2，配置文件.xml中 如下

```java
<bean id="car" class="com.jxufe.factoryBean.CarFactoryBean">
    <property name="brand" value="BMW"></property>
</bean>
```

**2.9基于注解的方式来装配bean的属性**

​	注解：@Component 基本注解 标识一个受spring的组件,

@Respository 标识持久层组件 、 @Service 标识服务层（业务层组件） @Controlller标识表现层组件

**• <context:component-scan> ：**

–base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包里及其子包中的所有类. 

–当需要扫描多个包时, 可以使用逗号分隔.

```java
<comtext:component-scan base-package="com.jxufe.factoryBean"
 resource-pattern="com.jxufe.factoryBean.test/*.class">
</comtext:component-scan>
```

–<context:include-filter> 子节点表示要包含的目标类

–<context:exclude-filter> 子节点表示要排除在外的目标类	

可以拥有若干个 <context:include-filter>和<context:exclude-filter>子节点。

**•@Autowired 注解自动装配具有兼容类型的单个 Bean属性**

–构造器, 普通字段(即使是非 public), 一切具有参数的方法都可以应用@Authwired 注解

–默认情况下, 所有使用 @Authwired 注解的属性都需要被设置. 当 Spring 找不到匹配的 Bean 装配属性时, 会抛出异常, 若某一属性允许不被设置, 可以设置 @Authwired 注解的 required 属性为 false

  –默认情况下,当IOC容器里存在多个类型兼容的Bean时,通过类型的自动装配将无法工作.此时可以在@Qualifier 注解里提供Bean的名称.Spring 允许对方法的入参标注 @Qualifiter 已指定注入Bean 的名称。

**2.9Spring4新特性 泛型依赖注入**

​	![1544502678032](C:\Users\anan\AppData\Roaming\Typora\typora-user-images\1544502678032.png)

关联关系在父类建立。