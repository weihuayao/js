****1 AspectJ** 

​	1.1基于注解的AspectJ

​	** Spring中启用AspectJ注解支持**

​	环境支持需要加入jar包 。maven依赖如下：

```java
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.1</version>
</dependency>
```

​	

```java
<comtext:component-scan base-package="com.jxufe.Aop.lmpl">
</comtext:component-scan>
<!--使用 AspectJ起作用 自动为匹配的类生成代理对象-->
 <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```

```java
@Aspect  切面只是一个带有 @Aspect 注解的 Java 类.
@Component 
public class menthonName
//声明的前置通知 在目标开始之前
@Before("execution(public int com.jxufe.Aop.lmpl.Caculator.*(int ,int))"
//@After: 后置通知, 在方法执行之后执行   无论是否有异常抛出。       
@After("execution(public int com.jxufe.Aop.lmpl.Caculator.*(int ,int))")
//@AfterRunning: 返回通知, 在方法返回结果之后执行
@AfterReturning(value="execution(public int com.jxufe.Aop.lmpl.Caculator.*(int ,int))" , returning="result")
//@AfterThrowing: 异常通知, 在方法抛出异常之后
@AfterThrowing(value="execution(public int com.jxufe.Aop.lmpl.Caculator.*(int ,int))" ,throwing = "ex")
//@Around: 环绕通知, 围绕着方法执行
  @Around("execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))")
public Object aroundMethod(ProceedingJoinPoint pjd){
Object result = null;
String methodName = pjd.getSignature().getName(); 
try {	//前置通知
	System.out.println("The method " + methodName + " begins with " +Arrays.asList(pjd.getArgs()));
	//执行目标方法
	result = pjd.proceed();
	//返回通知
System.out.println("The method " + methodName + " ends with " + result);
} catch (Throwable e) {
//异常通知
System.out.println("The method " + methodName + " occurs exception:" + e);
throw new RuntimeException(e);
}
//后置通知
System.out.println("The method " + methodName + " ends");
return result;
}
*/
} 
```

​	execution * com.atguigu.spring.ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中声明的所有方法,第一个 * 代表任意修饰符及任意返回值. 第二个 * 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名.

execution public * ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 接口的所有公有方法.

execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法

execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法。

在 AspectJ中,切入点execution表达式可以通过操作符&&,||, ! 结合起来 

•在 AspectJ切面中,可以通过 @Pointcut 注解将一个切入点声明成简单的方法.切入点的方法体通常是空的,因为将切入点定义与应用程序逻辑混在一起是不合理的.

```java
@Pointcut("execution(public int com.jxufe.Aop.lmpl.Caculator.*(int ,int))")
public  void declareJointPointExpression(){
}
@Before("declareJointPointExpression()")
public  void  beforeMethon(){
    System.out.println("the methon begins");
}

@After("execution(public int com.jxufe.Aop.lmpl.Caculator.*(int ,int))")
public void afterMethon(){
    System.out.println("end...");
}

@AfterReturning(pointcut="declareJointPointExpression()" , returning="result")
public void AfterRunning( Object result){
    System.out.println("result is " +result);
}
@AfterThrowing(pointcut="declareJointPointExpression()" ,throwing = "ex")
public  void exception(Exception ex){
    System.out.println("exception  is  " +ex);
}
```

​	1.2基于配置的xml

```java
<!-- 配置 bean -->
<bean id="arithmeticCalculator" 
	class="com.atguigu.spring.aop.xml.ArithmeticCalculatorImpl"></bean>

<!-- 配置切面的 bean. -->
<bean id="loggingAspect"
	class="com.atguigu.spring.aop.xml.LoggingAspect"></bean>

<bean id="vlidationAspect"
	class="com.atguigu.spring.aop.xml.VlidationAspect"></bean>

<!-- 配置 AOP -->
<aop:config>
	<!-- 配置切点表达式 -->
	<aop:pointcut expression="execution(* com.atguigu.spring.aop.xml.ArithmeticCalculator.*(int, int))" 
		id="pointcut"/>
	<!-- 配置切面及通知 -->
	<aop:aspect ref="loggingAspect" order="2">
		<aop:before method="beforeMethod" pointcut-ref="pointcut"/>
		<aop:after method="afterMethod" pointcut-ref="pointcut"/>
		<aop:after-throwing method="afterThrowing" pointcut-ref="pointcut" throwing="e"/>
		<aop:after-returning method="afterReturning" pointcut-ref="pointcut" returning="result"/>
		<!--  
		<aop:around method="aroundMethod" pointcut-ref="pointcut"/>
		-->
	</aop:aspect>	
	<aop:aspect ref="vlidationAspect" order="1">
		<aop:before method="validateArgs" pointcut-ref="pointcut"/>
	</aop:aspect>
</aop:config>
```

 

​	**2.spring对jdbc的支持**

	<!-- 导入资源文件 -->
	<context:property-placeholder location="classpath:db.properties"/>
	
	<!-- 配置 C3P0 数据源 -->
	<bean id="dataSource"
		class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="user" value="${jdbc.user}"></property>
		<property name="password" value="${jdbc.password}"></property>
		<property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
		<property name="driverClass" value="${jdbc.driverClass}"></property>
	<property name="initialPoolSize" value="${jdbc.initPoolSize}"></property>
	<property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
	</bean>
	
	<!-- 配置 Spirng 的 JdbcTemplate -->
	<bean id="jdbcTemplate" 
		class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<!-- 配置 NamedParameterJdbcTemplate, 该对象可以使用具名参数, 其没有无参数的构造器, 所以必须为其构造器指定参数 -->
	<bean id="namedParameterJdbcTemplate"
	class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
	<constructor-arg ref="dataSource"></constructor-arg>	
	</bean>
	
	<!-- 配置事务管理器 -->
	<bean id="transactionManager" 
	class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<!-- 启用事务注解 -->
	<tx:annotation-driven transaction-manager="transactionManager"/>

**3Spring中的事物管理**

•事务管理是企业级应用程序开发中必不可少的技术,  用来确保数据的完整性和一致性.

原子性(atomicity): 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用.

一致性(consistency): 一旦所有事务动作完成, 事务就被提交. 数据和资源就处于一种满足业务规则的一致性状态中.

隔离性(isolation): 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏.

持久性(durability): 一旦事务完成无论发生什么系统错误它的结果都不应该受到影响通常情况下事务的结果被写到持久化存储器中

•编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚. 在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码. 

声明式事务管理:大多数情况下比编程式事务管理更好用它将事务管理代码从业务方法中分离出来以声明的方式来实现事务管理

**3.1配置事务管理器**

```
<!-- 配置事务管理器 -->
<bean id="transactionManager" 
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"></property>
</bean> 

<!-- 启用事务注解 -->
<tx:annotation-driven transaction-manager="transactionManager"/>`
```

**3.2@Transactional 注解来标注事务方法.** 

为了将方法定义为支持事务处理的, 可以为方法添加 @Transactional 注解. 根据 Spring AOP 基于代理机制, 只能标注公有方法.

**3.3事物的传播行为**

默认值 require

![1544614526776](C:\Users\anan\AppData\Roaming\Typora\typora-user-images\1544614526776.png)

require_new

![1544614565519](C:\Users\anan\AppData\Roaming\Typora\typora-user-images\1544614565519.png)

**3.4并发事物导致的问题**

 –脏读: 对于两个事物 T1, T2, T1  读取了已经被 T2 更新但 还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的.

–不可重复读:对于两个事物 T1, T2, T1  读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.

–幻读:对于两个事物 T1, T2, T1  从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.

**3.5事务的隔离级别**

•Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE

•Mysql 支持 4 中事务隔离级别.

用 @Transactional注解声明式地管理事务时可以在@Transactional的isolation属性中设置隔离级别

•默认情况下只有未检查异常(RuntimeException和Error类型的异常)会导致事务回滚. 而受检查异常不会.•事务的回滚规则可以通过 @Transactional 注解的 rollbackFor 和 noRollbackFor 属性来定义. 这两个属性被声明为 Class[] 类型的, 因此可以为这两个属性指定多个异常类.

```java
//添加事务注解
//1.使用 propagation 指定事务的传播行为, 即当前的事务方法被另外一个事务方法调用时
//如何使用事务, 默认取值为 REQUIRED, 即使用调用方法的事务
//REQUIRES_NEW: 事务自己的事务, 调用的事务方法的事务被挂起. 
//2.使用 isolation 指定事务的隔离级别, 最常用的取值为 READ_COMMITTED
//3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚. 也可以通过对应的
//属性进行设置. 通常情况下去默认值即可. 
//4.使用 readOnly 指定事务是否为只读. 表示这个事务只读取数据但不更新数据, 
//这样可以帮助数据库引擎优化事务. 若真的事一个只读取数据库值的方法, 应设置 readOnly=true
//5.使用 timeout 指定强制回滚之前事务可以占用的时间. 
@Transactional(propagation=Propagation.REQUIRES_NEW,
//			isolation=Isolation.READ_COMMITTED,
//			noRollbackFor={UserAccountException.class})
	@Transactional(propagation=Propagation.REQUIRES_NEW,
			isolation=Isolation.READ_COMMITTED,
			readOnly=false,
			timeout=3)
```



```java
!-- 2. 配置事务属性 -->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
	<tx:attributes>
		<!-- 根据方法名指定事务的属性 -->
		<tx:method name="purchase" propagation="REQUIRES_NEW"/>
		<tx:method name="get*" read-only="true"/>
		<tx:method name="find*" read-only="true"/>
		<tx:method name="*"/>
	</tx:attributes>
</tx:advice>
```



